const cp = require('child_process')
const fs = require('fs')
const path = require('path')
const rimraf = require('rimraf')

const SIMPLE_MAIN_RE = /^main\.\d+\.m?js$/
const MAIN_RE = /^main\.(.+)\.m?js$/
const MAIN_ALL = 'main.all.js'

/**
 * Generates fixtures
 *
 * Each fixture is a directory with a `lib.js` file and a few `main.X.js`
 * files where `X` is an integer.
 * For each main file, it will generate a `cov.X.json` file containing coverage
 * for `lib.mjs` when using the corresponding main as the entry point.
 * It also generates a `cov.all.json` obtained by executing (importing) all
 * the entry points.
 *
 * Merging all the `cov.X.json` coverages should result in `cov.all.json`.
 */
async function main () {
  for (const fixtureName of getFixtures()) {
    await generateFixture(fixtureName)
  }
}

function getFixtures () {
  return fs.readdirSync(__dirname)
    .filter((child) => fs.statSync(path.join(__dirname, child)).isDirectory())
}

async function generateFixture (name) {
  const dir = path.join(__dirname, name)
  const simpleMains = getSimpleMains(dir)
  const mainAll = generateMainAll(simpleMains)
  await fs.promises.writeFile(path.join(dir, MAIN_ALL), mainAll)
  for (const simpleMain of [...simpleMains, MAIN_ALL]) {
    const id = MAIN_RE.exec(simpleMain)[1]
    const libCoverage = await getLibCoverage(dir, simpleMain)
    await fs.promises.writeFile(path.join(dir, `cov.${id}.json`), JSON.stringify(libCoverage, null, 2))
  }
}

function getSimpleMains (dir) {
  return fs.readdirSync(dir)
    .filter((child) => SIMPLE_MAIN_RE.test(child))
    .sort((a, b) => {
      a = parseInt(MAIN_RE.exec(a)[1])
      b = parseInt(MAIN_RE.exec(b)[1])
      return a - b
    })
}

function generateMainAll (mains) {
  return [
    '// DO NOT EDIT: generated by `generate-fixtures.js`',
    'const lib = require.resolve(\'./lib.js\')',
    'function main () {',
    ...mains.map(main => `  require(${JSON.stringify(`./${main}`)})\n  delete require.cache[lib]`),
    '}',
    'main()',
    '',
  ].join('\n')
}

async function getLibCoverage (dir, main) {
  const covDirName = `cov-${main}`
  const covDir = path.join(dir, covDirName)
  await rmDir(covDir)
  await spawnWithCoverage(dir, main, covDir)
  const coverages = await readCoverage(covDir)
  await rmDir(covDir)
  const urlEnd = path.join('test', 'fixtures', path.basename(dir), 'lib.js')
  for (const coverage of coverages) {
    if (coverage.url.endsWith(urlEnd)) {
      return {
        scriptId: '1',
        url: path.posix.join('/', 'test', 'fixtures', path.basename(dir), 'lib.js'),
        functions: coverage.functions
      }
    }
  }
  throw new Error(`Coverage not found for \`lib.js\` for ${path.join(dir, main)}`)
}

async function spawnWithCoverage (dir, main, covDir) {
  return new Promise((resolve, reject) => {
    const proc = cp.spawn(
      process.execPath,
      [main],
      {
        cwd: dir,
        env: {NODE_V8_COVERAGE: covDir},
      },
    )
    proc.once('close', (code, signal) => {
      if (code === 0) {
        resolve()
      } else {
        reject(new Error(`Non-zero return code for: ${path.join(dir, main)}`))
      }
    })
  })
}

async function rmDir (dir) {
  return new Promise((resolve, reject) => {
    rimraf(dir, (err) => {
      if (err !== null) {
        reject(err)
      } else {
        resolve()
      }
    })
  })
}

async function readCoverage (covDir) {
  const covChildren = fs.readdirSync(covDir)
  if (covChildren.length !== 1) {
    throw new Error(`Expected a single file in: ${covDir}`)
  }
  return JSON.parse(await fs.promises.readFile(path.join(covDir, covChildren[0]), {encoding: 'UTF-8'})).result
}

main()
